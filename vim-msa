#!/bin/sh -eu
# The VIM-based multiple sequence alignment (MSA) editor.
# The project is released under the General Public License (GPL), version 3.
# Copyright © 2018, Danil Semelenov, Stas Malavin.
path=${TMPDIR-/tmp}/${0##*/}
cat > "$path".vim << \EOF
function s:add_comment(index)
  call insert(s:comments, '', s:buffer_empty() ? 0 : a:index)
  call s:update_comments()
endfunction

function s:append_line(line)
  call setline(s:buffer_empty() ? 1 : line('$') + 1, a:line)
endfunction

function s:buffer_empty()
  return line('$') == 1 && getline(1) == ''
endfunction

function s:configure_comment(index)
  let b:index = a:index
  resize 3
  setlocal nobuflisted
  setlocal statusline=[Comment]
endfunction

function s:configure_comments()
  setlocal nobuflisted
  setlocal nomodifiable
  setlocal nowrap
  setlocal scrollbind
  setlocal statusline=[Comments]
  setlocal winfixwidth
  vertical resize 10
endfunction

function s:configure_sequences(type)
  autocmd TextChanged <buffer> call s:on_sequences_changed()
  inoremap <buffer> <CR> <Nop>
  let &l:filetype = a:type
  let s:deleted_comments = {}
  nnoremap <buffer> <silent> O :call <SID>add_comment(line('.') - 1)<CR>O
  nnoremap <buffer> <silent> gc :call <SID>edit_comment(line('.') - 1)<CR>
  nnoremap <buffer> <silent> o :call <SID>add_comment(line('.'))<CR>o
  setlocal backspace-=eol
  setlocal ignorecase
  setlocal nowrap
  setlocal scrollbind
endfunction

function s:configure_vim()
  highlight VertSplit cterm=NONE gui=NONE term=NONE
  set fillchars+=vert:│
  set laststatus=0
endfunction

function s:edit_comment(index)
  let view = winsaveview()
  silent split `=tempname()`
  call s:configure_comment(a:index)
  call setline(1, s:comments[a:index])
  wincmd p
  call winrestview(view)
  wincmd p
endfunction

function s:initialize_empty()
  call win_gotoid(1000)
  if !len(expand('%'))
    call s:configure_sequences('fasta')
    call s:update_comments([''])
  endif
endfunction

function s:main()
  autocmd BufReadCmd *.fa,*.faa,*.fas,*.fasta,*.ffn,*.fna,*.frn,*.fsa,*.seq call s:read_file('fasta', expand('%'))
  autocmd BufWriteCmd * call s:on_buffer_write()
  autocmd VimEnter * call s:initialize_empty()
  call s:configure_vim()
  call s:split_windows()
endfunction

function s:mark_modified()
  call win_gotoid(1000)
  setlocal modified
  wincmd p
endfunction

function s:on_buffer_write()
  if &statusline == '[Comment]'
    call s:update_comment(b:index, join(getline(0, '$'), ' '))
    close!
  else
    call s:write_file(&filetype, expand('%'))
  endif
endfunction

function s:on_sequences_changed()
  let [sequences, comments] = [line('$'), len(s:comments)]
  if sequences != comments
    let [start, end] = [getpos("'[")[1], getpos("']")[1]]
    if sequences > comments
      if end == sequences
        let start += 1
      endif
      let s:comments = (start - 2 == -1 ? [] : s:comments[:start - 2]) + map(range(start - 1, end - 1), {index, value -> get(s:deleted_comments, value, '')}) + s:comments[start - 1:]
    else
      let [first, last] = [start - 1, start + comments - sequences - 2]
      if s:buffer_empty()
        let last += 1
      endif
      for index in range(first, last)
        let s:deleted_comments[index] = s:comments[index]
      endfor
      call remove(s:comments, first, last)
      if !len(s:comments)
        let s:comments = ['']
      endif
    endif
    call s:update_comments()
  endif
endfunction

function s:read_fasta(path)
  let comments = []
  let prev_line = ''
  for line in readfile(a:path)
    if line !~ '^\s*$'
      if line =~ '^[>;]'
        if line !~ '^;' || prev_line !~ '^[>;]'
          call add(comments, substitute(line, '^[>;]\s*', '', ''))
          if exists('sequence')
            call s:append_line(sequence)
          endif
          let sequence = ''
        endif
      else
        let sequence .= substitute(line, '\*$', '', '')
      endif
    endif
    let prev_line = line
  endfor
  if exists('sequence')
    call s:append_line(sequence)
  endif
  return comments
endfunction

function s:read_file(type, path)
  call win_gotoid(1000)
  let [undo_levels, &l:undolevels] = [&l:undolevels, -1]
  %delete _
  execute printf('let comments = filereadable(a:path) ? s:read_%s(a:path) : []', a:type)
  let &l:undolevels = undo_levels
  call s:configure_sequences(a:type)
  call s:update_comments(comments)
endfunction

function s:split_windows()
  vnew
  call s:configure_comments()
  autocmd VimEnter * call win_gotoid(1000)
  autocmd WinEnter * if !win_id2win(1000) || !win_id2win(1001) | quitall! | endif
endfunction

function s:update_comment(index, comment)
  let s:comments[a:index] = a:comment
  call s:update_comments()
  call s:mark_modified()
endfunction

function s:update_comments(...)
  if a:0 >= 1
    let s:comments = a:1
  endif
  call win_gotoid(1001)
  setlocal modifiable
  %delete _
  call setline(1, map(copy(s:comments), {index, comment -> split(comment, '', 1)[0]}))
  setlocal nomodifiable
  wincmd p
endfunction

function s:write_fasta(path)
  for index in range(0, len(s:comments) - 1)
    call writefile([printf('>%s', s:comments[index])], expand('%'), 'a')
    let sequence = getline(index + 1)
    let range = len(sequence) ? range(0, len(sequence) - 1, 70) : [0]
    for index in range
      call writefile([sequence[index:index + 70 - 1]], a:path, 'a')
    endfor
  endfor
endfunction

function s:write_file(type, path)
  call win_gotoid(1000)
  call writefile([], a:path)
  execute printf('call s:write_%s(a:path)', a:type)
  setlocal nomodified
  echomsg printf('"%s" written', a:path)
endfunction

call s:main()
EOF
set -- --cmd "source $path.vim" "$@"
if [ -t 0 ]; then
  exec vim "$@"
else
  cat > "$path".fasta
  vim "$@" "$path".fasta < /dev/tty > /dev/tty
  cat "$path".fasta
  rm "$path".fasta
fi
